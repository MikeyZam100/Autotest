from .utils import *


class TestSuiteCleanerAgent(Runnable):
    """
    Cleans and sanitizes raw test code generated by TestSuiteGenAgent.
    Removes markdown, fixes incomplete lines, ensures all test functions have a body,
    and returns a syntactically valid Python test suite string.
    """

    def invoke(self, input_dict: dict) -> dict:
        """
        Args:
            input_dict: {
                "test_code": <str>,         # Raw test suite string from LLM
                "function_name": <str>,     # Name of function under test (for logging/fallback)
                "test_filename": <str>      # (Optional) Target test file path
            }
        Returns:
            {
                "cleaned_test_code": <str>,
                "status": "cleaned" | "placeholder" | <error>
            }
        """
        raw = input_dict.get("test_code", "")
        function_name = input_dict.get("function_name", "unknown")
        test_filename = input_dict.get("test_filename", "")

        # --- If empty or unusable, return a placeholder skipped test ---
        if not raw or not isinstance(raw, str) or not raw.strip():
            placeholder = (
                "import pytest\n\n"
                "@pytest.mark.skip(reason=\"LLM failed to generate test code.\")\n"
                f"def test_placeholder():\n"
                "    pass\n"
            )
            return {"cleaned_test_code": placeholder, "status": "placeholder"}

        # --- Remove markdown code fences (```python ... ```) ---
        code = raw.strip()
        if code.startswith("```"):
            code = re.sub(r"^```(?:python)?", "", code, flags=re.IGNORECASE | re.MULTILINE).strip()
            if code.endswith("```"):
                code = code[:-3].strip()

        # --- Normalize line endings and strip leading/trailing whitespace ---
        code = code.replace('\r\n', '\n').replace('\r', '\n').strip()

        # --- Remove leading empty docstrings or blank lines ---
        code = re.sub(r'^\s*("""|\'\'\').*?\1\s*', '', code, flags=re.DOTALL)
        code = code.lstrip('\n')

        # --- Split into lines for further processing ---
        lines = code.splitlines()
        clean_lines = []
        i = 0
        while i < len(lines):
            line = lines[i]
            stripped = line.strip()

            # --- If line starts with assert but doesn't end with ), discard it and all after ---
            if stripped.startswith("assert") and not stripped.endswith(")"):
                break

            # --- If line starts with def but doesn't end with :, discard it and all after ---
            if stripped.startswith("def") and not stripped.endswith(":"):
                break

            clean_lines.append(line)
            i += 1

        # --- Ensure all test functions have a body ---
        lines = clean_lines
        fixed_lines = []
        i = 0
        while i < len(lines):
            line = lines[i]
            fixed_lines.append(line)
            # Detect test function definition
            if re.match(r'^\s*def\s+test_[a-zA-Z0-9_]*\s*\(.*\)\s*:', line):
                # Look ahead to next line (if any)
                next_idx = i + 1
                needs_pass = False
                if next_idx >= len(lines):
                    needs_pass = True
                else:
                    next_line = lines[next_idx]
                    # If next line is blank or another function def, insert pass
                    if next_line.strip() == "" or re.match(r'^\s*def\s+', next_line):
                        needs_pass = True
                if needs_pass:
                    fixed_lines.append("    pass")
            i += 1

        # --- Remove trailing blank lines ---
        while fixed_lines and not fixed_lines[-1].strip():
            fixed_lines.pop()

        cleaned_code = "\n".join(fixed_lines)

        # --- Final fallback: if nothing left, return placeholder ---
        if not cleaned_code.strip():
            placeholder = (
                "import pytest\n\n"
                "@pytest.mark.skip(reason=\"LLM failed to generate test code.\")\n"
                f"def test_placeholder():\n"
                "    pass\n"
            )
            return {"cleaned_test_code": placeholder, "status": "placeholder"}

        return {"cleaned_test_code": cleaned_code,}